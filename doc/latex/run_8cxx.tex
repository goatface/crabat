\hypertarget{run_8cxx}{
\section{run.cxx File Reference}
\label{run_8cxx}\index{run.cxx@{run.cxx}}
}


Code to run the analysis.  


{\ttfamily \#include \char`\"{}run.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}Analyzer.cxx\char`\"{}}\par
{\ttfamily \#include \char`\"{}TRint.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}KVNucleus.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}KV2Body.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}TBrowser.h\char`\"{}}\par
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{run_8cxx_abeef1bcf28d6a0ea36da794caa67971d}{enewzsub\_\-} (int $\ast$z1, float $\ast$m1, float $\ast$e, char matter1\mbox{[}33\mbox{]}, int $\ast$unit\_\-pressure, float $\ast$pressure, float $\ast$temperature, int $\ast$unit\_\-thick, float $\ast$thick1, float $\ast$aft\_\-ene)
\begin{DoxyCompactList}\small\item\em Fortran energy loss subroutine. \end{DoxyCompactList}\item 
int \hyperlink{run_8cxx_a3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\begin{DoxyCompactList}\small\item\em main function of \hyperlink{run_8cxx}{run.cxx} which controls everything else. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Code to run the analysis. \begin{DoxyAuthor}{Author}
daid 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.0
\end{DoxyVersion}
Reads one or more input ROOT Trees generated by ridf2root.C \par
 Calls \hyperlink{Analyzer_8cxx}{Analyzer.cxx} on the data, and writes out histograms.\par
 Allows user input or automation to select run files.\par
 Reads input/output directories and run header informtion from run.conf\par
 Runtime options dictate how data will be analyzed (raw and/or detailed) and which type of data will be analyzed (ssd pad, ssd strip, ppac, tpc).\par
 \begin{DoxyDate}{Date}
07 Nov 2011 18:57:28 
\end{DoxyDate}


Definition in file \hyperlink{run_8cxx_source}{run.cxx}.



\subsection{Function Documentation}
\hypertarget{run_8cxx_abeef1bcf28d6a0ea36da794caa67971d}{
\index{run.cxx@{run.cxx}!enewzsub\_\-@{enewzsub\_\-}}
\index{enewzsub\_\-@{enewzsub\_\-}!run.cxx@{run.cxx}}
\subsubsection[{enewzsub\_\-}]{\setlength{\rightskip}{0pt plus 5cm}void enewzsub\_\- (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{z1, }
\item[{float $\ast$}]{m1, }
\item[{float $\ast$}]{e, }
\item[{char}]{matter1\mbox{[}33\mbox{]}, }
\item[{int $\ast$}]{unit\_\-pressure, }
\item[{float $\ast$}]{pressure, }
\item[{float $\ast$}]{temperature, }
\item[{int $\ast$}]{unit\_\-thick, }
\item[{float $\ast$}]{thick1, }
\item[{float $\ast$}]{aft\_\-ene}
\end{DoxyParamCaption}
)}}
\label{run_8cxx_abeef1bcf28d6a0ea36da794caa67971d}


Fortran energy loss subroutine. 

Uses Ziegler's method for energy loss. A subroutine for enewz. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em z1} & Proton number of ion. \\
\hline
\mbox{\tt in}  & {\em m1} & Nucleon number of ion. \\
\hline
\mbox{\tt in}  & {\em e} & Energy of ion (MeV/A). \\
\hline
\mbox{\tt in}  & {\em matter1} & Matter the ion passes through, as defined in SNKE\_\-MATTER.INC --- Case-\/insensitive.\par
 Must be 32 characters followed by the $\backslash$0 termination character. \\
\hline
\mbox{\tt in}  & {\em unit\_\-pressure} & Define the units of pressure: 0=solid target ; 1=Torr ; 2=mbar ; 3=atm. \\
\hline
\mbox{\tt in}  & {\em pressure} & Define the value of the pressure (0 for solid target). \\
\hline
\mbox{\tt in}  & {\em temperature} & Define the temperature in Kelvin (0 for solid target). \\
\hline
\mbox{\tt in}  & {\em unit\_\-thick} & Define the units of thickness: 1=mm ; 2=mg/cm$^{\mbox{2}}$  \\
\hline
\mbox{\tt in}  & {\em thick1} & Define the value of the thickness. \\
\hline
\mbox{\tt out}  & {\em aft\_\-ene} & Ion energy after energy loss in matter (MeV/A). \\
\hline
\end{DoxyParams}
\hypertarget{run_8cxx_a3c04138a5bfe5d72780bb7e82a18e627}{
\index{run.cxx@{run.cxx}!main@{main}}
\index{main@{main}!run.cxx@{run.cxx}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}
\label{run_8cxx_a3c04138a5bfe5d72780bb7e82a18e627}


main function of \hyperlink{run_8cxx}{run.cxx} which controls everything else. 

The main function gets the runtime options, can interact with the user to specify run number(s), reads the input ROOT Tree, passes the Tree to \hyperlink{classAnalyzer}{Analyzer}, Writes the histograms to a new Tree, and optionally launches a ROOT session with a TBrowser attached to the output .root file.\par
 Essentially everything is controlled from here.\par
 The parameters are just the standard form for getopt parsing. \begin{DoxySeeAlso}{See also}
\hyperlink{run_8h_a5ae07f63d6b390e42068d941038dadf2}{Usage} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em argc} & getopt argument count \\
\hline
\mbox{\tt in}  & {\em arcv} & getopt argument vector \\
\hline
\end{DoxyParams}


Definition at line 84 of file run.cxx.


\begin{DoxyCode}
{
  int run_no=0,run_no2=-1; // set default run numbers
  // set up the directory structure and file names to be read in
  char file_dir_in[100], file_dir_out[100], header[100];
 
  //getopt parsing
  int c;
  bool flag_type=false;
  bool flag_det=false;
  opterr = 0;
  while ((c = getopt (argc, argv, "R:H:I:Brdsxtp")) != -1)
   switch (c)
     {
     case 'R':
       flag_Run = true;
        sscanf(optarg,"%i",&run_no);
       break;
     case 'B':
       flag_Batch = true;
       break;
     case 'H':
       flag_Header = true;
        sscanf(optarg,"%s",&header[0]);
       break;
     case 'I':
       flag_Inpath = true;
        sscanf(optarg,"%s",&file_dir_in[0]);
       break;
     case 'r':
       flag_raw = true;
       flag_type=true;
       break;
     case 'd':
       flag_detail = true;
       flag_type=true;
       break;
     case 's':
       flag_ssd = true;
       flag_det=true;
       break;
     case 'x':
       flag_strip = true;
       flag_det=true;
       break;
     case 'p':
       flag_ppac = true;
       flag_det=true;
       break;
     case 't':
       flag_tpc = true;
       flag_det=true;
       break;
     case '?': 
       if (optopt == 'c')
         fprintf (stderr, "Option -%c requires an argument.\n", optopt);
       else if (isprint (optopt))
         fprintf (stderr, "Unknown option `-%c'.\n", optopt);
       else
         fprintf (stderr,
                  "Unknown option character `\\x%x'.\n",
                  optopt);
       Usage();
       return 1;
     default:
       Usage();
       return 1;
     }
   if (!flag_type || !flag_det){ // we need some kind of data to analyze!
     Usage();
     return 1;
   }
   if (flag_Batch && !flag_Run){ // we need a run number for batch mode
     Usage();
     return 1;
   }
  
  ifstream runheaders;
  //We get the run header from run.conf
  runheaders.open("run.conf");
  string runentry, str_comment = "#";
  int lines=0;
  while (!runheaders.eof()){
    getline(runheaders,runentry);
    if (runentry[0] != str_comment[0] && runentry.length()!=0){
      lines++;
      if (lines > 3) break; // these are run flags for crabat
      if (lines==1 && !flag_Inpath) sprintf(file_dir_in,"%s",runentry.c_str()); /
      / ROOT Input Tree location
      if (lines==2) sprintf(file_dir_out,"%s",runentry.c_str()); // ROOT Output T
      ree location
      if (lines==3 && !flag_Header) sprintf(header,"%s",runentry.c_str()); // Run
       header
    }   
  }
  runheaders.close();
  // set up the directory structure for file output
  char cmd[200];
  sprintf(cmd,"ls %s/%s/ > /dev/null",file_dir_out,header);
  cout << ".root files in targeted output directory: " << endl;
  if (system(cmd)) { // runs the system command.  if ls is successful, exit statu
      s 0, but if it failed exit status 1
    cout << "Creating output directory based on output directory: " << file_dir_o
      ut << " and header: " << header << endl; 
    sprintf(cmd,"mkdir %s/%s",file_dir_out,header); // if ls failed we need to cr
      eate the directory for output 
    if (system(cmd)){ cout << "ERROR: No write permission in local directory!" <<
       endl; return 1;} // if mkdir is not successful, report the error and quit
  }
  sprintf(cmd,"ls %s/%s/*.root 2> /dev/null",file_dir_out,header);
  if(system(cmd)){} // if statement only exists to avoid warn_unused_result
  //user friendly run selection
  if (run_no==0) { // run_no is init to 0, unless run is called with a run number
       explicity (batch mode)
    cout << "Existing runs are: " << endl;
    sprintf(cmd,"ls %s/%s*.root",file_dir_in,header);
    if (system(cmd)) {fprintf(stderr,"ERROR: input directory '%s' does not exist!
      \n",file_dir_in); return(1);} // if we can't find the location to read from, exit
       with fail status
    
    cout << endl << "Select a run to be analyzed \n";
    cout << "(ie: 1 means "<< file_dir_in <<   "/" <<  header << "0001.root \n";
    cout << "1-10 means processing runs 1 through 10): ";
  
    char runnums[200];
    cin >> runnums;
    sscanf(runnums,"%d-%d",&run_no,&run_no2);
  }
  Int_t run_proc = 0;
  if (run_no2==-1) { // only processing one run
    run_no2=run_no;
    cerr << "Processing run " << run_no <<  " only" << endl;
    run_proc = run_no;
  }
  else{
    cerr << "Processing run " << run_no <<  " through run " << run_no2 << endl;
  }
  char file_run[150];
  //exclude some run numbers for particular cases
  if (strcmp("30s_production",header)==0) {
    if (run_no==1006 || run_no==1007 || run_no==1008 || run_no==1009 || run_no==1
      010 || run_no==1016){
      cout << "Run number " << run_no << " is junk for 30S Production Runs" << en
      dl;
      return 0;
    }
    if (run_no==1024 || run_no==1027 ){
      cout << "Run number " << run_no << " is calibration for 30S Production Runs
      " << endl;
      return 0;
    }
  }
  
  // report what data will be analyzed
  cout << "raw data: " << flag_raw << endl << "detailed data: " << flag_detail <<
       endl <<
  "ssd: " << flag_ssd << endl <<  "ssd_strip: " << flag_strip << endl << "ppac: "
       << flag_ppac << endl << "tpc: " << flag_tpc << endl;
  
  Int_t nfiles; // count the number of files loaded
  TChain *ch=new TChain("rawdata"); // create a TChain in the case there is more 
      than one root file to process
  
  for (int rn=run_no;rn<=run_no2;rn++) {
    //make the right file name out of the run
    
    //get a cout on the rn with the printf %4.4d
    sprintf(file_run,"%s/%s%4.4d.root",file_dir_in,header,rn);
    //do the analysis part
    cout << "loading file:" << file_run << endl;
   
    //Checking if the file exists.
    ifstream ifile(file_run);
    if (!ifile.is_open()) {
       cerr << file_run << " could not be opened." << endl;
       return(1); // exit with fail status
    }
    ifile.close();
    
    nfiles=ch->Add(file_run);
  } // end for: run_no
  
  // Initalize the histograms
  HistInit();
  // ANALYZE THE DATA!
  Analyzer t(ch); t.Loop(run_proc,flag_raw,flag_detail,flag_ssd,flag_strip,flag_p
      pac,flag_tpc);
  //t.Show(0);
  
  // set up the histogram output file
  char spectra_name[150];
  if (run_no==run_no2) {sprintf(spectra_name,"%s/%s/%s-%d.root",file_dir_out,head
      er,header,run_no);}
  else {sprintf(spectra_name,"%s/%s/%s-%d_%d.root",file_dir_out,header,header,run
      _no,run_no2);}
  TFile *hist_file = new TFile(spectra_name,"RECREATE");
  
  HistWrite(); // Write the histograms
  hist_file->Write(); // write histograms to file
  hist_file->Close(); // close histogram file

  delete hist_file; // delete memory used for histogram file

  new TFile(spectra_name); // open the root file we made because I'm too lazy to 
      find it myself 
  
  // Create interactive interface
  if (!flag_Batch) { //interactive mode is on
    TRint *theApp = new TRint("ROOT example", &argc, argv, NULL, 0);
    // Call an object browser
    new TBrowser();
    // Run interactive interface
    theApp->Run();
  }
  
  // clean up memory allocation
  delete ch; // delete the chain
  HistClean(); // clean the memory allocated for historgrams (defined in run.h)
  
  return(0);    // exit with success status
}
\end{DoxyCode}
