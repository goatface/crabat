/*
 Copyright: 
 2010 daid KAHL, HASHIMOTO takashi, YAMAGUCHI hidetoshi 
 2011, 2012, 2013 daid KAHL

 This file is part of crabat

 crabat is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 crabat is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with crabat.  If not, see <http://www.gnu.org/licenses/>.
  
 In order to publish results obtained from crabat or any
 future derivative software, the authors must make reference
 to the paper describing it (in preparation): D. Kahl et al.
 ``Algorithms for Active Target Data Analysis'' 2013.  This is an 
 additional term to the license as stipulated in section 7b.
 Publication includes, but is not limited to: books, peer-
 reviewed journals, conference proceedings, annual reports, etc.
 
 If any other publication is submitted prior to the publication of 
 the above stated reference, the author(s) must send a verbatim copy
 of that manuscript to the authors of crabat and receive express 
 written consent to publish that work.  Failure to do so may result
 in our requesting the publisher to withdraw the publication on 
 the grounds that it violates this copyright.  This is an additional
 restriction outside the terms of the license, and shall supersede any
 any clauses therein.

*/

/**
@file run.cxx
@author daid
@version 1.0
@brief Code to run the analysis.
@details Reads one or more input ROOT Trees generated by ridf2root.C \n
Calls Analyzer.cxx on the data, and writes out histograms.\n
Allows user input or automation to select run files.\n
Reads input/output directories and run header informtion from run.conf\n
Runtime options dictate how data will be analyzed (raw and/or detailed) and which type of data will be analyzed
(ssd pad, ssd strip, ppac, tpc).\n
@date 07 Nov 2011 18:57:28 
*/

// If run from ROOT, exit with message
#if defined (__CINT__)
{
cout << "This is C++ code, not a ROOT macro!" << endl;
cout << "To continue, run:" << endl;
cout << "make" << endl;
cout << "./run" << endl;
gApplication->Terminate();
}
#endif
using namespace std;
#include "run.h" // mainly allocates memory for histograms
#include "Analyzer.cxx" // the analysis code
#include "TRint.h" // so we can run a ROOT session after analysis finishes
#include "KV2Body.h" 		// KaliVeda class

// how to get the code of this into doxygen...?
#include "TBrowser.h" // so we can open a TBrowser

/**
@brief Fortran energy loss subroutine. 
@details Uses Ziegler's method for energy loss.  A subroutine for enewz.
@param [in] z1 Proton number of ion.
@param [in] m1 Nucleon number of ion.
@param [in] e Energy of ion (MeV/A).
@param [in] matter1 Matter the ion passes through, as defined in SNKE_MATTER.INC &mdash; Case-insensitive.\n
Must be 32 characters followed by the \0 termination character.
@param [in] unit_pressure Define the units of pressure: 0=solid target ; 1=Torr ; 2=mbar ; 3=atm.
@param [in] pressure Define the value of the pressure (0 for solid target).
@param [in] temperature Define the temperature in Kelvin (0 for solid target).
@param [in] unit_thick Define the units of thickness: 1=mm ; 2=mg/cm<sup>2</sup>
@param [in] thick1 Define the value of the thickness.
@param [out] aft_ene Ion energy after energy loss in matter (MeV/A).
*/
extern "C" { 
	void enewzsub_(int *z1, float *m1, float *e, char matter1[33], int *unit_pressure, float *pressure, float *temperature, int *unit_thick, float *thick1, float *aft_ene);
}

/**
@brief main function of run.cxx which controls everything else.
@details The main function gets the runtime options, can interact with the user to specify run number(s), reads the input ROOT Tree, passes the Tree to Analyzer, Writes the histograms to a new Tree, and optionally launches a ROOT session with a TBrowser attached to the output .root file.\n
Essentially everything is controlled from here.\n
The parameters are just the standard form for getopt parsing.
@see Usage
@param [in] argc getopt argument count
@param [in] arcv getopt argument vector
*/
int main(int argc, char **argv)
{
  int run_no=0,run_no2=-1; // set default run numbers
  // set up the directory structure and file names to be read in
  char file_dir_in[100], file_dir_out[100], header[100];
 
  //getopt parsing
  int c;
  bool flag_type=false;
  bool flag_det=false;
  opterr = 0;
  while ((c = getopt (argc, argv, "R:H:I:Brdsxtp")) != -1)
   switch (c)
     {
     case 'R':
       flag_Run = true;
  	sscanf(optarg,"%i",&run_no);
       break;
     case 'B':
       flag_Batch = true;
       break;
     case 'H':
       flag_Header = true;
  	sscanf(optarg,"%s",&header[0]);
       break;
     case 'I':
       flag_Inpath = true;
  	sscanf(optarg,"%s",&file_dir_in[0]);
       break;
     case 'r':
       flag_raw = true;
       flag_type=true;
       break;
     case 'd':
       flag_detail = true;
       flag_type=true;
       break;
     case 's':
       flag_ssd = true;
       flag_det=true;
       break;
     case 'x':
       flag_strip = true;
       flag_det=true;
       break;
     case 'p':
       flag_ppac = true;
       flag_det=true;
       break;
     case 't':
       flag_tpc = true;
       flag_det=true;
       break;
     case '?': 
       if (optopt == 'c')
         fprintf (stderr, "Option -%c requires an argument.\n", optopt);
       else if (isprint (optopt))
         fprintf (stderr, "Unknown option `-%c'.\n", optopt);
       else
         fprintf (stderr,
                  "Unknown option character `\\x%x'.\n",
                  optopt);
       Usage();
       return 1;
     default:
       Usage();
       return 1;
     }
   if (!flag_type || !flag_det){ // we need some kind of data to analyze!
     Usage();
     return 1;
   }
   if (flag_Batch && !flag_Run){ // we need a run number for batch mode
     Usage();
     return 1;
   }
  
  ifstream runheaders;
  //We get the run header from run.conf
  runheaders.open("run.conf");
  string runentry, str_comment = "#";
  int lines=0;
  while (!runheaders.eof()){
    getline(runheaders,runentry);
    if (runentry[0] != str_comment[0] && runentry.length()!=0){
      lines++;
      if (lines > 3) break; // these are run flags for crabat
      if (lines==1 && !flag_Inpath) sprintf(file_dir_in,"%s",runentry.c_str()); // ROOT Input Tree location
      if (lines==2) sprintf(file_dir_out,"%s",runentry.c_str()); // ROOT Output Tree location
      if (lines==3 && !flag_Header) sprintf(header,"%s",runentry.c_str()); // Run header
    }   
  }
  runheaders.close();
  // set up the directory structure for file output
  char cmd[200];
  sprintf(cmd,"ls %s/%s/ > /dev/null",file_dir_out,header);
  cout << ".root files in targeted output directory: " << endl;
  if (system(cmd)) { // runs the system command.  if ls is successful, exit status 0, but if it failed exit status 1
    cout << "Creating output directory based on output directory: " << file_dir_out << " and header: " << header << endl; 
    sprintf(cmd,"mkdir %s/%s",file_dir_out,header); // if ls failed we need to create the directory for output 
    if (system(cmd)){ cout << "ERROR: No write permission in local directory!" << endl; return 1;} // if mkdir is not successful, report the error and quit
  }
  sprintf(cmd,"ls %s/%s/*.root 2> /dev/null",file_dir_out,header);
  if(system(cmd)){} // if statement only exists to avoid warn_unused_result
  //user friendly run selection
  if (run_no==0) { // run_no is init to 0, unless run is called with a run number explicity (batch mode)
    cout << "Existing runs are: " << endl;
    sprintf(cmd,"ls %s/%s*.root",file_dir_in,header);
    if (system(cmd)) {fprintf(stderr,"ERROR: input directory '%s' does not exist!\n",file_dir_in); return(1);} // if we can't find the location to read from, exit with fail status
    
    cout << endl << "Select a run to be analyzed \n";
    cout << "(ie: 1 means "<< file_dir_in <<   "/" <<  header << "0001.root \n";
    cout << "1-10 means processing runs 1 through 10): ";
  
    char runnums[200];
    cin >> runnums;
    sscanf(runnums,"%d-%d",&run_no,&run_no2);
  }
  Int_t run_proc = 0;
  if (run_no2==-1) { // only processing one run
    run_no2=run_no;
    cerr << "Processing run " << run_no <<  " only" << endl;
    run_proc = run_no;
  }
  else{
    cerr << "Processing run " << run_no <<  " through run " << run_no2 << endl;
  }
  char file_run[150];
  //exclude some run numbers for particular cases
  if (strcmp("30s_production",header)==0) {
    if (run_no==1006 || run_no==1007 || run_no==1008 || run_no==1009 || run_no==1010 || run_no==1016){
      cout << "Run number " << run_no << " is junk for 30S Production Runs" << endl;
      return 0;
    }
    if (run_no==1024 || run_no==1027 ){
      cout << "Run number " << run_no << " is calibration for 30S Production Runs" << endl;
      return 0;
    }
  }
  
  // report what data will be analyzed
  cout << "raw data: " << flag_raw << endl << "detailed data: " << flag_detail << endl <<
  "ssd: " << flag_ssd << endl <<  "ssd_strip: " << flag_strip << endl << "ppac: " << flag_ppac << endl << "tpc: " << flag_tpc << endl;
  
  //unused for now
  //Int_t nfiles; // count the number of files loaded
  TChain *ch=new TChain("rawdata"); // create a TChain in the case there is more than one root file to process
  
  for (int rn=run_no;rn<=run_no2;rn++) {
    //make the right file name out of the run
    
    //get a cout on the rn with the printf %4.4d
    sprintf(file_run,"%s/%s%4.4d.root",file_dir_in,header,rn);
    //do the analysis part
    cout << "loading file:" << file_run << endl;
   
    //Checking if the file exists.
    ifstream ifile(file_run);
    if (!ifile.is_open()) {
       cerr << file_run << " could not be opened." << endl;
       return(1); // exit with fail status
    }
    ifile.close();
    
    //nfiles=ch->Add(file_run); 
    ch->Add(file_run);
  } // end for: run_no
  
  // Initalize the histograms
  HistInit();
  // ANALYZE THE DATA!
  Analyzer t(ch); 
  t.Loop(run_proc,flag_raw,flag_detail,flag_ssd,flag_strip,flag_ppac,flag_tpc);
  //t.Show(0);
  
  // set up the histogram output file
  char spectra_name[150];
  if (run_no==run_no2) {sprintf(spectra_name,"%s/%s/%s-%d.root",file_dir_out,header,header,run_no);}
  else {sprintf(spectra_name,"%s/%s/%s-%d_%d.root",file_dir_out,header,header,run_no,run_no2);}
  TFile *hist_file = new TFile(spectra_name,"RECREATE");
  
  HistWrite(); // Write the histograms
  hist_file->Write(); // write histograms to file
  hist_file->Close(); // close histogram file

  delete hist_file; // delete memory used for histogram file

  new TFile(spectra_name); // open the root file we made because I'm too lazy to find it myself 
  
  // Create interactive interface
  if (!flag_Batch) { //interactive mode is on
    TRint *theApp = new TRint("ROOT example", &argc, argv, NULL, 0);
    // Call an object browser
    new TBrowser();
    // Run interactive interface
    theApp->Run();
  }
  
  // clean up memory allocation
  delete ch; // delete the chain
  HistClean(); // clean the memory allocated for historgrams (defined in run.h)
  
  return(0);	// exit with success status
}
